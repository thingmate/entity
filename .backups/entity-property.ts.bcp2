import { Action, type ActionLike } from '@xstd/action';
import {
  Flow,
  type FlowContext,
  type FlowIterator,
  mapOneArgument,
  type PushToPullOptions,
} from '@xstd/flow';
import { type EntityPropertyMapper } from './types/methods/map/entity-property-mapper.js';
import { type ObserveEntityPropertyFlow } from './types/properties/observe/observe-entity-property.flow.js';
import { type ReadEntityPropertyAction } from './types/properties/read/read-entity-property.action.js';
import { type WriteEntityPropertyAction } from './types/properties/write/write-entity-property.action.js';

export interface EntityPropertyOptions<GValue> {
  readonly read?: ActionLike<[], GValue>;
  readonly write?: ActionLike<[value: GValue], void>;
  readonly observe?: Flow<GValue, [optins?: PushToPullOptions]>;
}

/**
 * Represents an _abstract_ `property`: a **value** that can be read, written, or observed.
 *
 * @template GValue The type of the property value.
 */
export class EntityProperty<GValue> {
  // static get READABLE(): 1 {
  //   return 1;
  // }
  //
  // static get WRITABLE(): 2 {
  //   return 2;
  // }
  //
  // static get OBSERVABLE(): 4 {
  //   return 4;
  // }

  static readonly #defaultRead: Action<[], any> = new Action<[], unknown>(
    async (signal: AbortSignal): Promise<unknown> => {
      signal.throwIfAborted();
      throw new Error('Property is not readable.');
    },
  );

  static readonly #defaultWrite: Action<[value: any], void> = new Action<[value: unknown], void>(
    async (signal: AbortSignal): Promise<void> => {
      signal.throwIfAborted();
      throw new Error('Property is not writable.');
    },
  );

  static readonly #defaultObserve: Flow<any, [options?: PushToPullOptions]> = new Flow<
    unknown,
    [options?: PushToPullOptions]
  >(async function* ({ signal }: FlowContext): FlowIterator<unknown> {
    signal.throwIfAborted();
    throw new Error('Property is not observable.');
  });

  readonly #read: ReadEntityPropertyAction<GValue>;
  readonly #write: WriteEntityPropertyAction<GValue>;
  readonly #observe: ObserveEntityPropertyFlow<GValue>;

  constructor({ read, write, observe }: EntityPropertyOptions<GValue> = {}) {
    // this.#mode =
    //   (read !== undefined ? EntityProperty.READABLE : 0) &
    //   (write !== undefined ? EntityProperty.WRITABLE : 0) &
    //   (observe !== undefined ? EntityProperty.OBSERVABLE : 0);

    this.#read = read === undefined ? EntityProperty.#defaultRead : Action.of(read);
    this.#write = write === undefined ? EntityProperty.#defaultWrite : Action.of(write);
    this.#observe = observe === undefined ? EntityProperty.#defaultObserve : observe;
  }

  /* IO */

  get readable(): boolean {
    return this.#read !== EntityProperty.#defaultRead;
  }

  get read(): ReadEntityPropertyAction<GValue> {
    return this.#read;
  }

  get writable(): boolean {
    return this.#write !== EntityProperty.#defaultWrite;
  }

  get write(): WriteEntityPropertyAction<GValue> {
    return this.#write;
  }

  get observable(): boolean {
    return this.#observe !== EntityProperty.#defaultObserve;
  }

  get observe(): ObserveEntityPropertyFlow<GValue> {
    return this.#observe;
  }

  /* OPERATIONS */

  map<GNewValue>({ to, from }: EntityPropertyMapper<GValue, GNewValue>): EntityProperty<GNewValue> {
    return new EntityProperty<GNewValue>({
      read: this.readable ? this.read.then(to) : undefined,
      write: this.writable ? this.write.mapArguments(mapOneArgument(from)) : undefined,
      observe: this.observe.map(to),
    });
  }
}
